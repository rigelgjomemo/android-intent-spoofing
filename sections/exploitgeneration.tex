% !TEX root =  ../main.tex

\subsection{Exploit Proof Generation}
 \label{section:kaluzaTranslation}

To generate an exploit as a malicious state input state $V_I$, we chose to use the Kaluza constraint solver \cite{kaluza}. Kaluza is an efficient solver for formulas containing string variables and constraints in the form of string equalities, substring operations, numeric constraints over string lengths, and so on. The main challenge in using this string solver is translating the constraints computed in the previous step (expressed as Jimple code) into the language used by Kaluza.

Kaluza natively supports a set of string operations, such as string concatentation and string equality, and length equality. For other operations, not natively supported by Kaluza, we built a translation system for a set of Java (Jimple) standard library methods, focusing on string and integer constrains. This set together with the set of operations supported natively constitutes the \emph{solvable} library methods referred to as $solv\_stat$in Section \ref{sec:approach}.  Some examples of these custom translations are listed in Table~\ref{table:tabkaluza}.

\begin{table*}[t]
   \centering
    \begin{tabular}{|l|l|}
      \hline
      \textbf{Java} & \textbf{Kaluza formulation}\\
      \hline
      $a.contains("test")$ & $var\_a \in CapturedBrack(/.*test.*/, 0);$ \\
      \hline
      $a.indexOf("test")$ & $var\_a := T1 . T2;$ \\
                  & $0x0 == Len(T1);$ \\
                  & $T2 := T3 . T4;$ \\
                  & $T3 := T5 . T6;$ \\
                  & $T6 == "test";$ \\
                  & $T5 \notin CapturedBrack(/test/, 0);$ \\
              & $var\_a\_indexOf == Len(T5);$ \\
      \hline
      $new_a = a.replace("test", "newTest")$ & $var_a := T1 . T2;$ \\
                      & $T2 := T3 . T4;$ \\
                      & $T3 := T5 . T6;$ \\
                      & $T5 \in CapturedBrack(/test/, 0);$ \\
                      & $T7 \in CapturedBrack(/newTest/, 0);$ \\
                      & $T8 :=  T9 . T4;$ \\
                      & $T9 :=  T7 . T6;$ \\
                      & $var\_new\_a := T1 . T8;$ \\
      \hline
    \end{tabular}
    \caption{Kaluza constraints formulation example}
    \label{table:tabkaluza}
  \end{table*}

  Most of these translations rely on Kaluza regular expressions and constraints. For instance, the $String.replace$  method is translated by producing a conjunction of constraints:
  the string ($var_a$) is divided into parts ($T1$ and $T2$ in the example) in order to identify the correct
  string part to substitute ($T5$). The new string is then defined to contain the replaced part
  ($T7$) in addition to the other non-matching string parts that do not need replacement.
  A similar approach is adopted for the $indexOf$ method: instead of replacing the string, the formulation identifies the correct position of the first occurrence of the lookup string in the original string by identifying the matching string part.
  For sake of clarity we present a line-by-line discussion of the $String.replace$ formulation.
  Line $1$ defines the variable $\$var\_a$ as the concatenation of two substrings ($T1$ and $T2$).
  Since the string to replace be found in the middle of the string, this first
  splitting is not exhaustive. At Line $2$ and $3$ we proceed further splitting the substring $T2$ in three
  pieces: $T5$, $T6$ and $T4$. Thanks to this string representation and not bounding the lengths of the pieces
  we can handle any positioning of the replacement string.
  At line $4$ we use $CapturedBrack$ (a regular expression helper) to explicitly declare which one is the part
  containing the string to be replaced. Similarly at line $5$ we ensure to have a new string piece ($T7$)
  including the replacement string.
  The remaining constraints (Lines $6-8$) compose the new string by concatenating the string pieces,
  including $T7$.


  % Since Java and Kaluza are both statically typed, we did not had to care about type casting
  % explicitly. For this reason the lookup of the method intended to be translated is straight forward
  % and can be done by exactly matching the method signature. The Kaluza transformation is consistent
  % in different invocation of the same  method signature.

  It is important to note that, in general, not all of the methods included in symbolic formulas produced by the paths computation step can be translated into Kaluza. Examples include API calls with types that cannot be cast to a Kaluza type. For instance, in our example code in Figure~\ref{lst:example}, this happens with the instruction Base64Encoder.toString(bytes). Another typical example are API calls that we consider as atomic instructions. For these calls, we proceeded as follows: we created a report in the output of the tool, and manually proceeded to build an approximate Kaluza representation of their functionality. An example of such approximation is the $split$ method, which is a utility function to divide a string into pieces separated by a substring given in input to the function. $split$ returns an array, and arrays are hard to represent in Kaluza because
  they are defined as an unknown number of variables, while Kaluza accepts only defined numbers of variables. Our approximation consists in producing the entire string instead of an
  array of parts as returned value of the method.

% \begin{itemize}
%   \item \textbf{Alias binding}: by binding parameters to arguments we obtained a
% linear and simple representation of the intra-procedural flow. As we can see at Line~$1$ in the wxample, we adopted the
% method signature as namespace to local variables so to have a unique value name
% for each variable in the code flow. In order to produce this bindings we use the $<tainted>$ data structure contained in the fact.
%   \item \textbf{Constraints translation}: we implemented a class of utility
% functions to translate string comparisons methods to a formal Kaluza representation. We directly extract the comparison information from the fact's $<conditional-statemets>$ data structure. In order to correctly detect the control flow edge leading to the vulnerable statement (vulnerable sink), we locally explore the CFG (Control Flow Graph) and we possibly flip the constraint condition (Line~$2$ of the example).
% \end{itemize}

% \begin{itemize}
%   \item \textbf{Graph building}: as first step of the process, we are interested in producing an
%   unified Graph of the original control flow graph by removing all the statements that does not
%   involve any of the statements that operates or include either the \emph{base variable} or one
%   of its aliases. The resulting sub-graph is then obtained by recursively merging all the methods' graphs
%   starting from the sink to the \emph{base variable}.

%   Here below is presented a sketch of the algorithm used to obtain the desired graph.
%   Where:
%   \begin{itemize}
%   \item $graph$ is the resulting graph variable
%   \item $sink$ is the vulnerable statement
%   \item $statementsSet$ is the list of tracked statements from the IFDS analysis
%   \end{itemize}
%   The algorithms works as follows: starting from the vulnerable statement point in the code
%   the control flow graph is traversed backward (w.r.t. normal code execution order) jumping
%   from callee to callers until the \emph{entry point} variable is reached.

%   $extractMethod$ is the algorithm wrapper function taking care of managing inter-procedural calls.
%   After adding the vulnerable statement the algorithms iterates over the callees until the newly generated
%   graph has not been changed (convergence point).

%   \lstset{numbers=left, basicstyle=\ttfamily\footnotesize, caption=Subraph building., label=codelisting}
%   \begin{lstlisting}
% graph;
% sink;
% statementsSet; // list of captured statements
% extractGraph() {
%  context; // sink's method
%  contextGraph;

%  graph.addNode(sink);

%  addPredecessors(contextGraph, sink, sink);

%  repeat {
%   headMethod= methodOf(lastUpdatedHead);
%   caller= callerOf(headMethod);
%   context= methodOf(callerStmt);
%   contextGraph= extractGraph(context);

%   if (caller in statementsSet) {
%    addPredecessors(contextGraph, callerStmt, prevHead);
%   }

%  } until (graph.getHead() != lastUpdatedHead);
% }

% addPredecessors(contextGraph, currentStatement, graphHead) {
%  for (predecessor, i :
%     currentStatement.getPredecessors()) {
%    if (!currentStatement in statementsSet) {
%     addPredecessors(contextGraph, predecessor, graphHead);
%     return;
%    }
%    if (current statemet branches) {
%     if (i == 1) {
%      addNodesAndEdge(graphHead,
%         <Empty>);
%     }

%     addNodesAndEdge(predecessor, graphHead);

%     if (i == 0) {
%       addNodesAndEdge(graphHead,
%         <Empty>);
%     }
%    } else {
%      addNodesAndEdge(predecessor, graphHead);
%    }

%    addPredecessors(contextGraph, predecessor, newGraphHead);
%  }
% }

%   \end{lstlisting}
%    $addPredecessors$ iterates over statements inside a specific method body and it is in charge
%   of reconstructing intra-procedural code points from the original method's body to newly constructed graph.
%   This method is invocated from the precise program point from which the previous method was invocated
%   until the first statement in the method body.

%   The function first checks whether the current statement was tracked in the previous analysis step or not,
%   i.e. such statement affects somehow the \emph{base variable} (or one of its aliases) or not.
%   If a match is encountered and the statements is not a merging point (the graph branches),
%   the current statements is simply added to the graph and the next statement is taken in consideration.
%   If the statement is a merging point, since the then-else branches are positional in the graph semantic,
%   the right position for the next statement has to be preserved. This is obtained by checking
%   the index of the current statement in the predecessors list (0 or 1).

%   It has to be noticed that:
%   \begin{itemize}
%   \item the first statement in a method body has no predecessors
%   \item points in the code in which if-then-else blocks merges have two predecessors
%   \item all other statements have only one predecessor
%   \end{itemize}

%   $addNodesAndEdges$ method (not presented here) is a simple utility method to add the edge
%   between the two nodes in the right position.


  % In order to avoid clashes, local variable names are transformed by prefixing to them their method name.
  % For example variable $v$ of method $doSomethingElse$ presented in the example \ref{sec:graph_buinding} is transformed to
  % the variable name $doSomethingElse_v$.

After the constraint solver processes the translated formula, it provides a set of solutions for the ranges of variables for which that formula is satisfiable. In particular, each solution contains the ranges that the variables in $I_a$ must have in order to produce a desired output $O_m$.
Conversely, an unsatisfiable result produced by the solver means that the vulnerable sink cannot be reached, in practice, at run-time.

We note that the solution provided by Kaluza includes also values of (those untainted) variables which are independent from the attacker (the set $I_b$). However, due to the pruning of the control flow super-graph, the instructions operating on those variables are removed and therefore no constraints about those variables are present in the symbolic formula, leading to solutions that usually correspond with the whole domain of values.

\todo{Added}
Whereas in several cases the number of constraints encountered is quite limited, as the complexity of
the produced formula, we want to provide one example for which the constraint set was too cumbersome
for a manual analysis to succeed leading to an error-free constraint solution.
\lstset{numbers=left, basicstyle=\ttfamily\scriptsize, breaklines=true}
\begin{lstlisting}
$source.length > 0
$source.startsWith("+1") -> $tmp := $source.substring(2, $source.length - 1)
(not $source.startsWith("+1")) -> $tmp := $source
$tmp.match("/([2-9][0-8][0-9])\ *([2-9][0-9][0-9])\ *([0-9][0-9][0-9][0-9])/")
\end{lstlisting}

In this example, after ensuring that the input value $source$ length is greater than 0,
the prefix is stripped out (if any) in $tmp$.
This $tmp$ variable is then matched against a regular expression for validation purposes.

Our tool was able to traverse the control flow graph with the Jimple representation of this code fragment,
 and in the end obtain the solution $444494 4944$.
